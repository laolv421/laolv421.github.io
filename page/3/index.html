<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="信息安全的小搬运工">
<meta property="og:type" content="website">
<meta property="og:title" content="小黄驴的窝">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="小黄驴的窝">
<meta property="og:description" content="信息安全的小搬运工">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小黄驴的窝">
<meta name="twitter:description" content="信息安全的小搬运工">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>小黄驴的窝</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小黄驴的窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/认证应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/认证应用/" itemprop="url">认证应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-20T18:58:43+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Okta"><a href="#Okta" class="headerlink" title="Okta"></a>Okta</h1><p>Infrastructure-as-a-Service(IaaS)，Platform-as-a-Service(PaaS)，Software-as-a-Service(SaaS)</p>
<h1 id="九州云腾"><a href="#九州云腾" class="headerlink" title="九州云腾"></a>九州云腾</h1><h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h1><p>这里主要介绍阿里云的身份认证和访问控制应用。</p>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>RAM (Resource Access Management) 是阿里云提供的资源访问控制服务。RAM用户是代表任意的通过控制台或OpenAPI操作阿里云资源的人、系统或应用程序。RAM允许您在云账号下创建并管理多个用户，每个用户都有唯一的用户名、登录密码或访问密钥。<br><img src="/img/认证应用/ram.png" width="500" align="center/"></p>
<h2 id="STS"><a href="#STS" class="headerlink" title="STS"></a>STS</h2><p>阿里云STS (Security Token Service) 是为阿里云账号（或RAM用户）提供短期访问权限管理的云服务。通过STS，您可以为联盟用户（您的本地账号系统所管理的用户）颁发一个自定义时效和访问权限的访问凭证。联盟用户可以使用STS短期访问凭证直接调用阿里云服务API，或登录阿里云管理控制台操作被授权访问的资源。<br><img src="/img/认证应用/sts.png" alt="阿里云STS"></p>
<h1 id="authlib"><a href="#authlib" class="headerlink" title="authlib"></a>authlib</h1><p>Token Endpoint Auth Methods（令牌端点认证方法）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure></p>
<p>其中 Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW 来认证客户，这种认证方法为client_secret_basic。<br>（1）none: The client is a public client which means it has no client_secret<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br><span class="line">&amp;client_id=s6BhdRkqt3</span><br></pre></td></tr></table></figure></p>
<p>（2）client_secret_post: The client uses the HTTP POST parameters<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br><span class="line">&amp;client_id=s6BhdRkqt3&amp;client_secret=gX1fBat3bV</span><br></pre></td></tr></table></figure></p>
<p>（3）client_secret_basic: The client uses HTTP Basic Authorization<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure></p>
<p>（4）JWT方式<br>JSON Web Token</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://blog.csdn.net/lionzl/article/details/53006803" target="_blank" rel="noopener">【笔记】阿里云RAM</a><br>[2] <a href="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/pdf/RAM-user-guide-intl-zh-2017-09-30.pdf" target="_blank" rel="noopener">阿里云访问控制文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/14/http认证方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/http认证方式/" itemprop="url">http认证方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-14T11:19:08+08:00">
                2018-09-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTP认证方式"><a href="#HTTP认证方式" class="headerlink" title="HTTP认证方式"></a>HTTP认证方式</h2><p>HTTP定义了两个官方的认证协议：HTTP Basic Authentication（基本认证）和HTTP Digest Authentication（摘要认证），除此之外不同浏览器还支持其他不同的认证方式，例如：chromium支持NTLM和Negotiate，微软http认证支持如下<br><img src="/img/http认证方式/微软http认证.png" width="800" align="center"><br>另外，还有一些其他协议，包括Bearer（<a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">RFC 6750</a>，OAuth2中定义）、MAC（<a href="https://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05" target="_blank" rel="noopener">draft-hammer-oauth-v2-mac-token-05</a>）、HOBA（<a href="https://tools.ietf.org/html/rfc7486" target="_blank" rel="noopener">RFC 7486</a>）、Mutual（<a href="https://tools.ietf.org/html/draft-ietf-httpauth-mutual-11" target="_blank" rel="noopener">draft-ietf-httpauth-mutual</a>）有的还处于draft版。这里我们主要介绍几个常见的HTTP认证，basic、digest、bearer、MAC。</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="一般认证的四个步骤"><a href="#一般认证的四个步骤" class="headerlink" title="一般认证的四个步骤"></a>一般认证的四个步骤</h3><p><img src="/img/http认证方式/认证4步骤.png" alt="认证的四个步骤"><br>质询过程中，服务器会返回一条401 Unauthorized响应，并在WWW-Authenticate首部说明如何（Basic）以及在哪里进行（realm）认证，如下例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 401 Authorization Required</span><br><span class="line">WWW-Authenticate: Basic realm=<span class="string">"Family"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="安全域"><a href="#安全域" class="headerlink" title="安全域"></a>安全域</h3><p>安全域要有一个描述形的字符名，以帮助用户清楚要使用哪个用户名和密码，同时在安全域中列出服务器主机名也是很有帮助的。</p>
<h3 id="代理认证"><a href="#代理认证" class="headerlink" title="代理认证"></a>代理认证</h3><p>中间的代理服务器也可以实现认证功能，可以在代理服务器上对访问策略进行集中管理，因此通过代理服务器提供对某组织内部资源的同意访问控制是一种很便捷的方式。代理的步骤与web服务器验证步骤类似：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unauthorized status code: 407</span><br><span class="line">Proxy-Authenticate</span><br><span class="line">Proxy-Authorization</span><br><span class="line">Proxy-Authentication-Info</span><br></pre></td></tr></table></figure></p>
<h3 id="WWW-Authentication"><a href="#WWW-Authentication" class="headerlink" title="WWW-Authentication"></a>WWW-Authentication</h3><p>如果客户端没有认证就访问服务器保护的资源，服务器会返回WWW-Authentication在包头中，WWW-Authentication的格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">challenge = <span class="string">"MAC"</span> [ RWS 1<span class="comment">#param ]</span></span><br><span class="line">param = error / auth-param</span><br><span class="line">error = <span class="string">"error"</span> <span class="string">"="</span> quoted-string</span><br></pre></td></tr></table></figure></p>
<p>challenge代表认证方式，例如bearer、MAC等；param表示参数，可以是error、realm等，例子如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">WWW-Authenticate: MAC error=<span class="string">"The MAC credentials expired"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h2><h3 id="1-格式"><a href="#1-格式" class="headerlink" title="1. 格式"></a>1. 格式</h3><p>基本认证是客户端提供username和password的一种认证，它不需要cookie、sessions等其他验证因素。基本认证会在HEAD中加入Authorization，同时username和password并没有加密，而是通过如下方法构建：<br>（1）username和password用冒号相连为一个字符串：<em>username:password</em></p>
<p>（2）并且这个字符串用Base64编码</p>
<p>（3）加入Basic关键字，如下例子，username：john，password：secret<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --header <span class="string">"Authorization: Basic am9objpzZWNyZXQ="</span> my-website.com</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/http认证方式/基本认证包.png" width="600" align="center"></p>
<h3 id="2-安全性"><a href="#2-安全性" class="headerlink" title="2. 安全性"></a>2. 安全性</h3><p>基本认证安全性的考虑主要有如下几点：<br>（1）username和password没有加密，即使在安全信道中传输，每次传输都暴露它们并不是一个好选择；</p>
<p>（2）第三方用户可以捕获对服务器进行重放攻击，以获得对服务器的访问权。</p>
<p>（3）一般基本认证会和SSL配合使用，这样会变得更安全。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><p>在友好环境，或者隐私保护不十分必要的环境中，可以通过基本认证来提供便捷的访问控制保护。这是基于HTTP协议的比较传统的身份验证方案，但是还存在。</p>
<h2 id="摘要认证"><a href="#摘要认证" class="headerlink" title="摘要认证"></a>摘要认证</h2><h3 id="1-对基本认证的改进"><a href="#1-对基本认证的改进" class="headerlink" title="1. 对基本认证的改进"></a>1. 对基本认证的改进</h3><p>摘要认证是另一种HTTP认证协议，对基本认证协议进行了安全升级，进行了如下改进：<br>（1）不会以明文发送密码；</p>
<p>（2）防止恶意用户捕获并重放认证的握手过程；</p>
<p>（3）有选择性地防止对报文内容的篡改；</p>
<h3 id="2-握手机制"><a href="#2-握手机制" class="headerlink" title="2. 握手机制"></a>2. 握手机制</h3><p>摘要认证采用了若干技术，单向函数、随机数防止重放攻击（WWW-Authenticate质询中从服务器传送到客户端）等。简单握手机制如下：<br>（1）服务器产生随机数；</p>
<p>（2）WWW-Authenticate（质询）：服务器发送域、随机数nonce和算法；</p>
<p>（3）从算法集中选择，计算出密码和其他数据的摘要，放入Authorization Header中返回服务器；如果客户端要对服务器进行认证，可以发送客户端随机数cnonce；</p>
<p>（4）服务器对摘要进行验证和比较是否匹配，可以产生下一个随机数，产生摘要发送给客户端认证；</p>
<h3 id="3-与安全性相关的数据"><a href="#3-与安全性相关的数据" class="headerlink" title="3. 与安全性相关的数据"></a>3. 与安全性相关的数据</h3><h4 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H(&lt;data&gt;) = MD5(&lt;data&gt;)</span><br><span class="line">KD(&lt;secret,&lt;data&gt;) = H(concatenate(&lt;secret&gt;:&lt;data&gt;))</span><br></pre></td></tr></table></figure>
<h4 id="A1"><a href="#A1" class="headerlink" title="A1"></a>A1</h4><p>A1的数据块只涉及安全信息，与底层自身无关。RFC 2617根据算法定义了两种计算A1的方式<br>（1）MD5，为每条请求运行单向散列函数</p>
<p>（2）MD5-sess，只在第一次WWW-Authenticate握手时运行一次单向散列函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5             A1 = &lt;user&gt;:&lt;realm&gt;:&lt;password&gt;</span><br><span class="line">MD5-sess        A1 = MD5(&lt;user&gt;:&lt;realm&gt;:&lt;password&gt;):&lt;nonce&gt;:&lt;cnonce&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="A2"><a href="#A2" class="headerlink" title="A2"></a>A2</h4><p>A2表示与报文自身有关的信息，比如URL、请求方法和报文实体的主体部分。A2防止方法、资源或报文被篡改。保护质量（qop）算法对A2定义如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qop未定义            A2 = &lt;request-method&gt;:&lt;uri-directive-value&gt;</span><br><span class="line">qop = <span class="string">"auth"</span>        A2 = &lt;request-method&gt;:&lt;uri-directive-value&gt;</span><br><span class="line">qop = <span class="string">"auth-int"</span>    A2 = &lt;request-method&gt;:&lt;uri-directive-value&gt;:H(&lt;request-entity-body&gt;)</span><br></pre></td></tr></table></figure></p>
<p>uri-directive-value表示请求行中的请求URI，可能是”*”、absoluteURL或者abs_path</p>
<h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qop 未定义                    alg = KD(H(A1), &lt;nonce&gt;:H(A2))</span><br><span class="line">qop = <span class="string">"auth"</span>或<span class="string">"auth-int"</span>     alg = KD(H(A1), &lt;nonce&gt;:&lt;nc&gt;:&lt;cnonce&gt;:&lt;qop&gt;:H(A2))</span><br></pre></td></tr></table></figure>
<h4 id="摘要认证首部"><a href="#摘要认证首部" class="headerlink" title="摘要认证首部"></a>摘要认证首部</h4><p><img src="/img/http认证方式/摘要认证首部.png" alt="摘要认证首部"></p>
<h3 id="4-安全性"><a href="#4-安全性" class="headerlink" title="4. 安全性"></a>4. 安全性</h3><p>（1）首部篡改<br>摘要认证重点在于提供防篡改认证机制，没有加密数据</p>
<h2 id="Cookie认证"><a href="#Cookie认证" class="headerlink" title="Cookie认证"></a>Cookie认证</h2><h2 id="Token认证（Token-Authentication）"><a href="#Token认证（Token-Authentication）" class="headerlink" title="Token认证（Token Authentication）"></a>Token认证（Token Authentication）</h2><p>随着RESTful API的应用，单页应用程序和微服务的兴起，基于令牌的认证已经变得更加普遍。Token认证和JWT加密密不可分。常见的令牌包括JWT（JSON Web Token）、SWT（简单网络令牌）和SAML（安全断言标记语言）。</p>
<h3 id="Token认证与Cookie认证的区别？"><a href="#Token认证与Cookie认证的区别？" class="headerlink" title="Token认证与Cookie认证的区别？"></a>Token认证与Cookie认证的区别？</h3><p>token认证是无状态的，而基于session的认证意味着在您的服务器（或在Redis等）中的某个地方保存着状态用以识别用户。</p>
<p>基于Session的认证流程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 用户输入其登录信息</span><br><span class="line">2. 服务器验证信息是否正确，并创建一个session，然后将其存储在数据库中</span><br><span class="line">3. 具有sessionID的Cookie将放置在用户浏览器中</span><br><span class="line">4. 在后续请求中，会根据数据库验证sessionID，如果有效，则接受请求</span><br><span class="line">5. 一旦用户注销应用程序，会话将在客户端和服务器端都被销毁</span><br></pre></td></tr></table></figure></p>
<p>基于Token的认证流程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 用户输入其登录信息</span><br><span class="line">2. 服务器验证信息是否正确，并返回已签名的token</span><br><span class="line">3. token储在客户端，最常见的是存储在<span class="built_in">local</span> storage中，但也可以存储在session存储或cookie中</span><br><span class="line">4. 之后的HTTP请求都将token添加到请求头里</span><br><span class="line">5. 服务器解码JWT，并且如果令牌有效，则接受请求</span><br><span class="line">6. 一旦用户注销，令牌将在客户端被销毁，不需要与服务器进行交互一个关键是，令牌是无状态的。后端服务器不需要保存令牌或当前session的记录。</span><br></pre></td></tr></table></figure></p>
<h3 id="BEARER-Token"><a href="#BEARER-Token" class="headerlink" title="BEARER Token"></a>BEARER Token</h3><p>Bearer token是建立在HTTP/1.1版本之上的access token类型，由认证服务器产生，需要TLS（Transport Layer Security）提供安全支持；客户端在携带token请求用户的受保护资源时，需要保证token的安全性，以防止token被窃取或篡改。Bearer在OIDC中的格式为JWT（Json Web Token），在OAuth2中的格式为opaque。</p>
<h4 id="opaque格式"><a href="#opaque格式" class="headerlink" title="opaque格式"></a>opaque格式</h4><p>Bearer token在OAuth2中定义的格式为opaque，目前RCF 6750中没有定义bearer token的实现方式，但是规定了bearer token的合法结构，包括token由字母数字特殊字符组成（alphanumeric），定义如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b64token = 1*( ALPHA / DIGIT / <span class="string">"-"</span> / <span class="string">"."</span> / <span class="string">"_"</span> / <span class="string">"~"</span> / <span class="string">"+"</span> / <span class="string">"/"</span> ) *<span class="string">"="</span></span><br></pre></td></tr></table></figure></p>
<p>转换成正则表达式为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[A-Za-z0-9\-\._~\+\/]+=*/</span><br></pre></td></tr></table></figure></p>
<p>通常opaque格式中的服务生成随机字符串，并将它们存储在数据库中，以及相关的用户和范围信息。</p>
<h4 id="Error-Codes"><a href="#Error-Codes" class="headerlink" title="Error Codes"></a>Error Codes</h4><p>（1）invalid request：请求参数问题，包括缺少参数、重复参数、不支持的参数提交等，返回的状态码是<strong>400（Bad Request）</strong>；</p>
<p>（2）invalid token：access token过期、销毁、伪造等，返回的状态码为<strong>401（Unauthorized）</strong>；</p>
<p>（3）insufficient scope：access token的权限不够，请求需要更高的权限，返回的状态码是<strong>403（Forbidden）</strong>可能同时包括需要访问受保护资源的”scope”属性；</p>
<h4 id="Bearer-token的传输方式"><a href="#Bearer-token的传输方式" class="headerlink" title="Bearer token的传输方式"></a>Bearer token的传输方式</h4><p>以下为RFC 6750定义了三种传输bearer token的方式：<br><strong>（1）放在Authentication请求header</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /resource HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Bearer mF_9.B5f-4.1JqM</span><br></pre></td></tr></table></figure></p>
<p><strong>（2）放在请求体中</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /resource HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">access_token=mF_9.B5f-4.1JqM</span><br></pre></td></tr></table></figure></p>
<p>放在请求体重需要有一些条件，如下：<br>（I）在header中必须有”Content-Type”头且值为”application/x-www-form-urlencoded”，也就是规定编码方式为URL编码；</p>
<p>（II）实体要遵循URL编码；</p>
<p>（III）请求体是single-part；</p>
<p>（IV）实体必须由ASCII码构成；</p>
<p>（V）禁止使用”GET”方式；</p>
<p><strong>（3）放在URI请求参数中</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure></p>
<h4 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h4><p>（1）Token manufacture/modification<br>攻击者可能会伪造token，或者修改token，比如延长有效期，扩大访问权限等；</p>
<p>（2）Token disclosure<br>token可能包含认证和一些敏感信息；</p>
<p>（3）Token Redirect<br>攻击者用一个资源服务器产生的token去申请其他资源服务器的资源；</p>
<p>（4）Token Replay<br>攻击者用曾曾使用过的token重新请求；</p>
<h3 id="MAC-Token"><a href="#MAC-Token" class="headerlink" title="MAC Token"></a>MAC Token</h3><p>前面介绍了BEARER类型的token，RFC6750明确说明该类型token需要TLS（Transport Layer Security）提供安全支持。虽然现今大部分站点都已经或正在由HTTP向HTTPS迁移，但是仍然会有站点继续在使用HTTP，在这类站点中BEARER类型的token存在安全隐患，这个时候MAC类型的token正是用武之地，MAC类型的token设计的主要目的就是为了应对不可靠的网络环境。</p>
<p>MAC类型相对于BEARER类型对于用户资源请求的区别在于，BEARER类型只需要携带授权服务器下发的token即可，而对于MAC类型来说，除了携带授权服务器下发的token，客户端还要携带时间戳，nonce，以及在客户端计算得到的mac值等信息，并通过这些额外的信息来保证传输的可靠性。</p>
<h4 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h4><p>MAC认证和Basic认证比较相似，但是用mac算法计算出来的mac值来替换Basic认证中的key（密码）。因为Mac认证使用对称算法中的key，所以需要在客户端和服务器之间生成一个对称秘钥，这个过程发生在客户端注册中（此过程需要TLS下完成）。标准协议（draft）提供了两种颁发mac凭证的方法：<br>（1）OAuth2中的mac类型的access token；<br>具体有关OAuth2可以查看另一篇文章《OAuth2协议基础》，认证服务器颁发MAC类型的凭证包括access token外，必须包括如下字段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access token: MAC key identifier</span><br><span class="line">secret: MAC key</span><br><span class="line">algorithm: hmac-sha-1</span><br></pre></td></tr></table></figure></p>
<p>（2）扩展HTTP Header中”Set-Cookie”；<br>Mac token标准定义了MAC-key和MAC-Algorithm cookie的属性，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=example.com;</span><br><span class="line">MAC-Key=8yfrufh348h; MAC-Algorithm=hmac-sha-1</span><br></pre></td></tr></table></figure></p>
<p>其中SID代表MAC key identifier，结合MAC-Key和MAC-Algorithm可以计算之后客户端请求的mac值</p>
<h5 id="MAC凭证流程"><a href="#MAC凭证流程" class="headerlink" title="MAC凭证流程"></a>MAC凭证流程</h5><p>客户端注册之后，mac凭证包含以下4个必须属性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAC key identifier: jd93dh9dh39D</span><br><span class="line">MAC key: 8yfrufh348h</span><br><span class="line">MAC algorithm: hmac-sha-1</span><br><span class="line">Issue time: Thu, 02 Dec 2010 21:39:45 GMT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 四种属性允许如下元素构成</span></span><br><span class="line">%x20-21 / %x23-5B / %x5D-7E</span><br><span class="line">; Any printable ASCII character except <span class="keyword">for</span> &lt;<span class="string">"&gt; and &lt;\&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>客户端通过计算凭证的有效时间来构建认证Header，并生成一个随机数用来构建nonce<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Age: 273156（单位为秒）</span><br><span class="line">Random string: di3hvdf8</span><br><span class="line">Nonce: 273156:di3hvdf8</span><br></pre></td></tr></table></figure></p>
<p>通过算法hmac-sha-1计算请求mac，构建Authorization请求头。其中body hash是可选选项，例如对于如下请求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /request HTTP/1.1</span><br><span class="line">Host: example.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">hello=world%21</span><br></pre></td></tr></table></figure></p>
<p>将会包装为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /request HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Authorization: MAC id=<span class="string">"jd93dh9dh39D"</span>,nonce=<span class="string">"273156:di3hvdf8"</span>,bodyhash=<span class="string">"k9kbtCIy0CkI3/FEfpS/oIDjk6k="</span>,</span><br><span class="line">mac=<span class="string">"W7bdMZbv9UWOTadASIQHagZyirA="</span></span><br><span class="line"></span><br><span class="line">hello=world%21</span><br></pre></td></tr></table></figure></p>
<p>服务器收到请求之后，计算mac来进行验证。在传输过程中，包会转换成一个string，换行符用%0A表示（URL编码），HTTP请求方法也会转为大写，Host：hostname用小写表示。</p>
<h5 id="MAC的安全性考虑"><a href="#MAC的安全性考虑" class="headerlink" title="MAC的安全性考虑"></a>MAC的安全性考虑</h5><p>（1）MAC Key的传输问题<br>上面描述的两种传输方式都需要建立在TLS下保密发送，否则无论在Header还是Cookie都会泄露MAC Key。</p>
<p>（2）MAC Key的存储问题<br>因为客户端、服务器双方需要共享MAC Key来进行hmac-sha-1等MAC算法，MAC Key的存储非常关键，需要重点考虑不能轻易被攻击者拿到。</p>
<p>（3）拒绝服务攻击<br>如果服务器需要track nonce来判断nonce的新鲜度，那么当攻击者能够极快的速度产生非常多的nonce的话，服务器需要查找nonce是否被使用过，这样攻击者会很快耗尽服务器的资源。</p>
<p>（4）Timing Attacks（时间攻击）<br>因为服务器计算完mac值后要与客户端请求的进行比对，考虑到字符串是一个字符一个字符操作，如果根据拒绝时间可能会找到从哪位开始出现问题，这样可以构造mac值来欺骗服务器。所以，设计返回时间最好是固定的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《HTTP权威指南》</li>
<li><a href="https://blog.risingstack.com/web-authentication-methods-explained/" target="_blank" rel="noopener">Web Authentication Methods Explained</a></li>
<li><a href="https://segmentfault.com/a/1190000008481722" target="_blank" rel="noopener">HTTP验证大法(Basic Auth,Session, JWT, Oauth, Openid)</a></li>
<li><a href="https://www.chromium.org/developers/design-documents/http-authentication" target="_blank" rel="noopener">HTTP authentication, The Chromium Projects</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/understanding-http-authentication" target="_blank" rel="noopener">Understanding http authentication, Microsoft</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication" target="_blank" rel="noopener">HTTP authentication, Mozilla</a></li>
<li><a href="https://www.oauth.com/" target="_blank" rel="noopener">OAuth 2.0 Servers, by Aaron Parecki</a></li>
<li><a href="https://my.oschina.net/wangzhenchao/blog/856964" target="_blank" rel="noopener">OAuth2.0协议原理与实现：TOKEN生成算法</a></li>
<li><a href="https://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05" target="_blank" rel="noopener">HTTP Authentication: MAC Authentication (draft-hammer-oauth-v2-mac-token-05)</a></li>
<li><a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">RFC6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></li>
<li><a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JSON Web Token (JWT)</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/13/SSO相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/SSO相关/" itemprop="url">SSO相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-13T10:46:08+08:00">
                2018-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/认证/" itemprop="url" rel="index">
                    <span itemprop="name">认证</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="OpenID、OIDC和OAuth"><a href="#OpenID、OIDC和OAuth" class="headerlink" title="OpenID、OIDC和OAuth"></a>OpenID、OIDC和OAuth</h1><p>简单说来，OpenID是关于认证（authentication）的协议，OAuth是关于授权（authorization）的协议，而OpenID Connect简称OIDC，在OAuth2的基础上加入认证功能，可以做到既认证又授权。认证解决了如何确认身份，也就是对方的确是他所宣称的；授权则是关于决定对方被允许做的事，也就是访问控制范围。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/09/13/SSO相关/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/07/Tomcat-SSL配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/07/Tomcat-SSL配置/" itemprop="url">Tomcat-SSL配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-07T15:01:47+08:00">
                2018-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/linux/LVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/linux/LVM/" itemprop="url">LVM的简单命令总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T20:22:10+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LVM对于磁盘分区、扩容都很有帮助，本文意义在于回顾并总结一些工作中用到的LVM简单命令。LVM是Logical Volume Management的缩写，这次针对CentOS7，xfs文件系统。</p>
<h3 id="LVM中pv、vg和lv之间的关系"><a href="#LVM中pv、vg和lv之间的关系" class="headerlink" title="LVM中pv、vg和lv之间的关系"></a>LVM中pv、vg和lv之间的关系</h3><p>下图形象地展现了physical volume、volume group和logical volume之间的关系：<br><img src="/img/LVM/LVM_1.png" alt="sourcelist文件的截图" title="LVM的截图1"><br>剩下两张图为细节上的体现：<br><img src="/img/LVM/LVM_2.gif" alt="sourcelist文件的截图" title="LVM的截图2"><br><img src="/img/LVM/LVM_3.jpg" alt="sourcelist文件的截图" title="LVM的截图3"></p>
<h3 id="LVM命令"><a href="#LVM命令" class="headerlink" title="LVM命令"></a>LVM命令</h3><h4 id="1-分区：fdisk命令"><a href="#1-分区：fdisk命令" class="headerlink" title="1.分区：fdisk命令"></a>1.分区：fdisk命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk /dev/sda</span><br></pre></td></tr></table></figure>
<h4 id="2-创建physical-volume"><a href="#2-创建physical-volume" class="headerlink" title="2.创建physical volume"></a>2.创建physical volume</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pvcreate /dev/sda2</span><br></pre></td></tr></table></figure>
<h3 id="3-扩容volume-group-vg名字假设为cl"><a href="#3-扩容volume-group-vg名字假设为cl" class="headerlink" title="3.扩容volume group(vg名字假设为cl)"></a>3.扩容volume group(vg名字假设为cl)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vgextend cl /dev/sda2</span><br></pre></td></tr></table></figure>
<h3 id="4-扩容logical-volume"><a href="#4-扩容logical-volume" class="headerlink" title="4.扩容logical volume"></a>4.扩容logical volume</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lvextend -l +50%FREE -r /dev/cl/root</span><br></pre></td></tr></table></figure>
<p>如果命令忘记加 -r (resize) 的话，需要加如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xfs_growfs /dev/cl/root</span><br></pre></td></tr></table></figure></p>
<h3 id="5-补充命令"><a href="#5-补充命令" class="headerlink" title="5.补充命令"></a>5.补充命令</h3><p>(1) pvs、vgs、lvs分别对应physical volume display、volume group display、logical volume display三种查看命令；<br>(2) fdisk -l、cat /proc/partitions两个命令都可以查看分区情况；<br>(3) partprobe命令用于重读（某）分区表，无需重启系统；<br>(4) df命令用于查看磁盘（分区）使用情况，-h(human readable) -T(display filesystem type)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/Docker实践/Docker实践(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/Docker实践/Docker实践(一)/" itemprop="url">Docker实践(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T20:22:10+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>笔者记录Docker下的安装目的是为了回头查看方便，因此只记录了关于Ubuntu的Docker的安装，其他版本的docker安装可以查看<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">《Docker — 从入门到实践》</a>，这里面非常详细地介绍了各个主要系统的安装。</p>
<h3 id="1-卸载旧版本"><a href="#1-卸载旧版本" class="headerlink" title="1. 卸载旧版本"></a>1. 卸载旧版本</h3><p>旧版本的Docker称为docker或者docker-engine，使用以下命令卸载旧版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure></p>
<h3 id="2-安装内核模块"><a href="#2-安装内核模块" class="headerlink" title="2. 安装内核模块"></a>2. 安装内核模块</h3><p>从Ubuntu 14.04开始，一部分内核模块移到了可选内核模块包 ( linux-image-extra-* ) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。 AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS 。</p>
<p>如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</span><br></pre></td></tr></table></figure>
<h3 id="3-使用APT安装前的准备"><a href="#3-使用APT安装前的准备" class="headerlink" title="3. 使用APT安装前的准备"></a>3. 使用APT安装前的准备</h3><p>由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS 传输的软件包以及CA证书。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure>
<p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看；为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>然后，我们需要向source.list中添加Docker软件源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository <span class="string">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure>
<p>以上命令会添加稳定版本的Docker CE APT镜像源，如果需要最新或者测试版本的Docker CE请将stable改为edge或者test。从Docker 17.06开始，edge test版本的APT镜像源也会包含稳定版本的Docker。</p>
<h3 id="4-安装Docker-CE"><a href="#4-安装Docker-CE" class="headerlink" title="4. 安装Docker CE"></a>4. 安装Docker CE</h3><p>更新apt软件包缓存，并安装docker-ce：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>
<h3 id="5-启动Docker-CE"><a href="#5-启动Docker-CE" class="headerlink" title="5. 启动Docker CE"></a>5. 启动Docker CE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>Ubuntu 14.04 请使用以下命令启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker start</span><br></pre></td></tr></table></figure>
<h3 id="6-建立docker用户组"><a href="#6-建立docker用户组" class="headerlink" title="6. 建立docker用户组"></a>6. 建立docker用户组</h3><p>默认情况下， docker命令会使用Unix socket与Docker引擎通讯。而只有root用户和docker组的用户才可以访问Docker引擎的Unix socket。出于安全考虑，一般Linux系统上不会直接使用root 用户。因此，更好地做法是将需要使用docker的用户加入docker用户组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>将当前用户加入docker组：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></p>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h3 id="7-测试Docker是否安装正确"><a href="#7-测试Docker是否安装正确" class="headerlink" title="7. 测试Docker是否安装正确"></a>7. 测试Docker是否安装正确</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">ca4f61b1923c: Pull complete</span><br><span class="line">Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line">1. The Docker client contacted the Docker daemon.</span><br><span class="line">2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">(amd64)</span><br><span class="line">3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">executable that produces the output you are currently reading.</span><br><span class="line">4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">to your terminal.</span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">$ docker run -it ubuntu bash</span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line">https://cloud.docker.com/</span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line">https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure>
<p>若能正常输出以上信息，则说明安装成功。</p>
<h3 id="8-镜像加速"><a href="#8-镜像加速" class="headerlink" title="8. 镜像加速"></a>8. 镜像加速</h3><p>（a）对于使用systemd的系统（Ubuntu 16.04+、Debian 8+、CentOS 7），请在/etc/docker/daemon.json中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"registry-mirrors"</span>: [</span><br><span class="line"><span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#之后重启服务</span></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>（b）对于使用upstart的系统（Ubuntu 14.04、Debian 7 Wheezy）而言，编辑/etc/default/docker文件，在其中的DOCKER_OPTS中添加获得的加速器配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">"--registry-mirror=https://registry.docker-cn.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#之后重新启动服务</span></span><br><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker — 从入门到实践</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/Docker实践/Docker实践(二) /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/Docker实践/Docker实践(二) /" itemprop="url">Docker实践（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T20:22:10+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用Docker镜像"><a href="#使用Docker镜像" class="headerlink" title="使用Docker镜像"></a>使用Docker镜像</h2><p>本文主要参考<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker — 从入门到实践</a>的框架内容，并补充了一些该文之外的内容，希望回头看会有不一样的收获。</p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>Docker中有大量的镜像可以使用，在<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>中，如下图所示；</p>
<p><img src="/img/Docker实践/Docker实践（二）/docker_hub.png" alt="Docker Hub" title="Docker Hub"></p>
<p>选择redis的detail，有比较详细的说明；</p>
<p><img src="/img/Docker实践/Docker实践（二）/docker_redis.png" alt="Docker redis" title="Docker redis"></p>
<p>从Docker镜像仓库获取镜像的命令是docker pull。其命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<p>具体的选项可以通过docker pull –help命令看到，这里我们说一下镜像名称的格式。<br>（a）Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是 Docker Hub。<br>（b）仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt; 。对于 Docker Hub，如果不给出用户名，则默认为 library ，也就是官方镜像。</p>
<p>下面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:16.04 ，因此将会获取官方镜像 library/ubuntu 仓库中标签为 16.04 的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:16.04</span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:16.04</span><br></pre></td></tr></table></figure>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:16.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm ubuntu:16.04 bash</span><br></pre></td></tr></table></figure>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure>
<p><img src="/img/Docker实践/Docker实践（二）/docker_image_ls.png" alt="Docker列出镜像" title="Docker列出镜像"></p>
<p>列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间，镜像ID则是镜像的唯一标识，一个镜像可以对应多个标签。可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker system df</span><br></pre></td></tr></table></figure>
<p><img src="/img/Docker实践/Docker实践（二）/docker_system_df.png" alt="Docker查看镜像" title="Docker查看镜像"></p>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<p>不加任何参数的情况下， docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像，docker image ls有好几个参数可以帮助做到这个事情；<br>（a）根据仓库名列出镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu</span><br></pre></td></tr></table></figure>
<p>（b）列出特定的某个镜像，也就是说指定仓库名和标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu:16.04</span><br></pre></td></tr></table></figure>
<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>如果要删除本地的镜像，可以使用docker image rm命令，格式为；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<p>例子：<br>（a）需要删除所有仓库名为redis的镜像；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure>
<p>（b）删除所有在mongo:3.2之前的镜像；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure>
<h3 id="理解镜像"><a href="#理解镜像" class="headerlink" title="理解镜像"></a>理解镜像</h3><p>现在让我们以定制一个Web服务器为例子，来讲解镜像是如何构建的；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>这段命令使用nginx镜像启动了一个叫webserver的容器，映射了80端口，可以用浏览器去访问nginx服务器；假设希望改成欢迎Docker的文字，我们可以使用docker exec命令进入容器，修改其内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it webserver bash</span><br></pre></td></tr></table></figure>
<p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 docker diff 命令看到具体的改动；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker diff webserver</span><br></pre></td></tr></table></figure>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而Docker提供了一个docker commit命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker commit的语法格式如下</span></span><br><span class="line">$ docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure>
<p>我们可以用下面的命令将容器保存为镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">--author <span class="string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> \</span><br><span class="line">--message <span class="string">"修改了默认网页"</span> \</span><br><span class="line">webserver \</span><br><span class="line">nginx:v2</span><br></pre></td></tr></table></figure>
<p>我们还可以用docker history具体查看镜像内的历史记录，如果比较 nginx:latest 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> nginx:v2</span><br></pre></td></tr></table></figure>
<p>注意：使用docker commit命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用；因为会有大量的无关内容被添加进来，黑箱镜像难以维护等问题。</p>
<h3 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h3><p>如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是Dockerfile。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。<a href="https://store.docker.com/" target="_blank" rel="noopener">Docker Store</a>中包含了很多基础的官方镜像，除了选择现有镜像为基础镜像外，Docker还存在一个特殊的镜像，名为scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。下面谈谈Dockerfile中的常见的指令；</p>
<p>（1）FROM指定基础镜像，是Dockerfile中的第一条指令<br>（2）RUN指令用来执行命令，其格式有两种：<br>&emsp;&emsp;（a）shell格式：RUN&lt;命令&gt;，就像直接在命令行中输入的命令一样；<br>&emsp;&emsp;（b）exec格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。<br>（3）COPY复制文件，和RUN指令一样，也有两种形式；</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker — 从入门到实践</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/apt-get常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/apt-get常用命令/" itemprop="url">apt-get的常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T20:22:10+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>因为apt-get为Debian的最常用的命令，而自己又比较喜欢使用Ubuntu版本，特单独拿出来总结一下，以便使用并且在原基础上进行补充。</p>
<h2 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h2><h3 id="apt-get是什么？"><a href="#apt-get是什么？" class="headerlink" title="apt-get是什么？"></a>apt-get是什么？</h3><p>apt是Debian及其衍生发行版的高级软件包管理器，英文为Advanced Packaging Tools。APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程,apt-get是一个下载安装软件包的简单命令行接口，一般需要root权限执行，所以一般跟着sudo命令。<br>使用apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。/etc/apt/sources.list是存放这些地址列表的配置文件，其格式如下： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb [web或ftp地址] [发行版名字] [main/contrib/non-free]</span><br></pre></td></tr></table></figure>
<p>下面的图片截取自sourcelist文件</p>
<p><img src="/img/apt-get常用命令/sourcelist.png" alt="sourcelist文件的截图" title="sourcelist文件的截图"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get [选项] 命令</span><br></pre></td></tr></table></figure>
<p>命令如下：</p>
<p>update - 重新获取软件包列表 </p>
<p>upgrade - 进行更新 </p>
<p>install - 安装新的软件包 </p>
<p>remove - 移除软件包 </p>
<p>autoremove - 自动移除全部不使用的软件包 </p>
<p>purge - 移除软件包和配置文件 </p>
<p>source - 下载源码档案 </p>
<p>build-dep - 为源码包配置编译依赖 </p>
<p>dist-upgrade - 发行版升级</p>
<p>dselect-upgrade - 依照 dselect 的选择更新 </p>
<p>clean - 清除下载的归档文件 </p>
<p>autoclean - 清除旧的的已下载的归档文件 </p>
<p>check - 检验是否有损坏的依赖</p>
<p>选项： </p>
<p>-h 本帮助文件。 </p>
<p>-q 输出到日志 - 无进展指示 </p>
<p>-qq 不输出信息，错误除外 </p>
<p>-d 仅下载 - 不安装或解压归档文件 </p>
<p>-s 不实际安装。模拟执行命令</p>
<p>-y 假定对所有的询问选是，不提示 </p>
<p>-f 尝试修正系统依赖损坏处 </p>
<p>-m 如果归档无法定位，尝试继续</p>
<p>-u 同时显示更新软件包的列表 </p>
<p>-b 获取源码包后编译 -V 显示详细的版本号</p>
<h3 id="常见的使用例子"><a href="#常见的使用例子" class="headerlink" title="常见的使用例子"></a>常见的使用例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache search packagename 在软件包列表中搜索字符串</span><br><span class="line">$ apt-cache show packagename 获取包的相关信息，如说明、大小、版本等</span><br><span class="line">$ apt-cache depends packagename 了解使用依赖</span><br><span class="line">$ apt-cache rdepends packagename 是查看该包被哪些包依赖</span><br><span class="line">$ apt-cache search string 在软件包列表中搜索字符串 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ apt-get install packagename 安装包</span><br><span class="line">$ apt-get install packagename --reinstall 重新安装包</span><br><span class="line">$ apt-get -f install 修复安装”-f = –fix-missing”</span><br><span class="line">$ apt-get remove packagename 删除包，保留配置文件</span><br><span class="line">$ apt-get remove packagename --purge 删除包，包括删除配置文件等，会把已装或已卸的软件都备份在硬盘上</span><br><span class="line">$ apt-get autoclean 清理无用的包，可以让这个命令来删除你已经删掉的软件</span><br><span class="line">$ apt-get clean 清理无用的包，这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的</span><br><span class="line">$ apt-get update 更新源</span><br><span class="line">$ apt-get upgrade 更新已安装的包</span><br><span class="line">$ apt-get dist-upgrade 升级系统到新版本</span><br><span class="line">$ apt-get dselect-upgrade 使用 dselect 升级</span><br><span class="line">$ apt-get build-dep packagename 安装相关的编译环境</span><br><span class="line">$ apt-get <span class="built_in">source</span> packagename 下载该包的源代码</span><br><span class="line">$ apt-get check 检查是否有损坏的依赖</span><br><span class="line"></span><br><span class="line">$ dpkg --force-all --purge packagename 有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险</span><br><span class="line">$ dpkg -S file——这个文件属于哪个已安装软件包</span><br><span class="line">$ dpkg -L package——列出软件包中的所有文件</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.cnblogs.com/pswzone/archive/2012/04/09/2438885.html" target="_blank" rel="noopener">apt-get常用命令</a></li>
<li><a href="http://bbs.chinaunix.net/tree/index_168_1/" target="_blank" rel="noopener">Ubuntu apt-get 使用指南</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/maven问题修复/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/maven问题修复/" itemprop="url">Maven中出现的问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T20:22:10+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="maven中出现的问题总结"><a href="#maven中出现的问题总结" class="headerlink" title="maven中出现的问题总结"></a>maven中出现的问题总结</h2><h3 id="问题1：如何使用maven指令执行-java-main？"><a href="#问题1：如何使用maven指令执行-java-main？" class="headerlink" title="问题1：如何使用maven指令执行 java main？"></a>问题1：如何使用maven指令执行 java main？</h3><p>一种比较直接的解决方式，直接找到classes路径下，使用java指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp target/classes org.ts.App</span><br></pre></td></tr></table></figure>
<p>这样比较麻烦，下面的方法可以直接使用maven命令来执行：</p>
<p>（1）命令行运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Without arguments:</span></span><br><span class="line">$ mvn <span class="built_in">exec</span>:java -Dexec.mainClass=<span class="string">"com.vineetmanohar.module.Main"</span> </span><br><span class="line"><span class="comment"># With arguments:</span></span><br><span class="line">$ mvn <span class="built_in">exec</span>:java -Dexec.mainClass=<span class="string">"com.vineetmanohar.module.Main"</span> -Dexec.args=<span class="string">"arg0 arg1 arg2"</span></span><br><span class="line"><span class="comment"># With runtime dependencies in the CLASSPATH:</span></span><br><span class="line">$ mvn <span class="built_in">exec</span>:java -Dexec.mainClass=<span class="string">"com.vineetmanohar.module.Main"</span> -Dexec.classpathScope=runtime</span><br></pre></td></tr></table></figure>
<p>（2）Running in a phase in pom.xml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line"> &lt;plugins&gt;</span><br><span class="line">  &lt;plugin&gt;</span><br><span class="line">   &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;<span class="built_in">exec</span>-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">   &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">     &lt;phase&gt;<span class="built_in">test</span>&lt;/phase&gt;</span><br><span class="line">     &lt;goals&gt;</span><br><span class="line">      &lt;goal&gt;java&lt;/goal&gt;</span><br><span class="line">     &lt;/goals&gt;</span><br><span class="line">     &lt;configuration&gt;</span><br><span class="line">      &lt;mainClass&gt;com.vineetmanohar.module.CodeGenerator&lt;/mainClass&gt;</span><br><span class="line">      &lt;arguments&gt;</span><br><span class="line">       &lt;argument&gt;arg0&lt;/argument&gt;</span><br><span class="line">       &lt;argument&gt;arg1&lt;/argument&gt;</span><br><span class="line">      &lt;/arguments&gt;</span><br><span class="line">     &lt;/configuration&gt;</span><br><span class="line">    &lt;/execution&gt;</span><br><span class="line">   &lt;/executions&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line"> &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>（3）Running in a profile in pom.xml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line"> &lt;profile&gt;</span><br><span class="line">  &lt;id&gt;code-generator&lt;/id&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">   &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">     &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;<span class="built_in">exec</span>-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">     &lt;executions&gt;</span><br><span class="line">      &lt;execution&gt;</span><br><span class="line">       &lt;phase&gt;<span class="built_in">test</span>&lt;/phase&gt;</span><br><span class="line">       &lt;goals&gt;</span><br><span class="line">        &lt;goal&gt;java&lt;/goal&gt;</span><br><span class="line">       &lt;/goals&gt;</span><br><span class="line">       &lt;configuration&gt;</span><br><span class="line">        &lt;mainClass&gt;com.vineetmanohar.module.CodeGenerator&lt;/mainClass&gt;</span><br><span class="line">        &lt;arguments&gt;</span><br><span class="line">         &lt;argument&gt;arg0&lt;/argument&gt;</span><br><span class="line">         &lt;argument&gt;arg1&lt;/argument&gt;</span><br><span class="line">        &lt;/arguments&gt;</span><br><span class="line">       &lt;/configuration&gt;</span><br><span class="line">      &lt;/execution&gt;</span><br><span class="line">     &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">   &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line"> &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure>
<h3 id="问题2：-ERROR-No-goals-have-been-specified-for-this-build-You-must-specify-a-valid-lifecycle-phase-or-a-goal-in-the-format-…？"><a href="#问题2：-ERROR-No-goals-have-been-specified-for-this-build-You-must-specify-a-valid-lifecycle-phase-or-a-goal-in-the-format-…？" class="headerlink" title="问题2：[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format …？"></a>问题2：[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format …？</h3><p>可用的lifecycle phases有: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy</p>
<p>在编译环节的goals加上任意一个就好，例如compile，。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/共识算法（Consensus Protocol）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小黄驴">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黄驴的窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/共识算法（Consensus Protocol）/" itemprop="url">共识算法（Consensus Protocol）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-21T20:22:10+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><h3 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h3><p>CAP 原理最早由 Eric Brewer 在 2000 年，ACM 组织的一个研讨会上提出猜想，后来 Lynch等人进行了证明。该原理被认为是分布式系统领域的重要原理。</p>
<p>分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。<br>（1）一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性；</p>
<p>（2）可用性（Availablity）：在有限时间内，任何非失败节点都能应答请求；</p>
<p>（3）分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。</p>
<p>比较直观地理解，当网络可能出现分区时候，系统是无法同时保证一致性和可用性的。要么，节点收到请求后因为没有得到其他人的确认就不应答，要么节点只能应答非一致的结<br>果。好在大部分时候网络被认为是可靠的，因此系统可以提供一致可靠的服务；当网络不可靠时，系统要么牺牲掉一致性（大部分时候都是如此），要么牺牲掉可用性。</p>
<h4 id="弱化一致性"><a href="#弱化一致性" class="headerlink" title="弱化一致性"></a>弱化一致性</h4><p>对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。例如网站静态页面内容、实时性较弱的查询类数据库等，CouchDB、Cassandra 等为此设<br>计。</p>
<h4 id="弱化可用性"><a href="#弱化可用性" class="headerlink" title="弱化可用性"></a>弱化可用性</h4><p>对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis 等为此设计。Paxos、Raft 等算法，主要处理这种情况。</p>
<h4 id="弱化分区容忍性"><a href="#弱化分区容忍性" class="headerlink" title="弱化分区容忍性"></a>弱化分区容忍性</h4><p>现实中，网络分区出现概率减小，但较难避免。某些关系型数据库、ZooKeeper 即为此设计。实践中，网络通过双通道等机制增强可靠性，达到高稳定的网络通信。</p>
<h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><p>分布式系统的一致性算法就是指一组机器协同工作，即便其中有某些机器宕机了，系统还能正常对外提供服务。以前通常都喜欢用Paxos来讲解一致性算法，但是Paxos本身很复杂，代码实现也很难，于是催生了Raft这个更加简单易懂的一致性算法，难得的是，它的效果跟Paxos差不多。介绍Raft算法之前先介绍复制状态机。</p>
<h4 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h4><p>一致性算法是在复制状态机的背景下提出来的。在复制状态机中，集群中的服务器从相同的状态中生成同样的副本，即使其中有些服务器宕机了，客户端还是可以继续执行操作，复制状态机可以用来解决分布式系统中许多容错问题。大型分布式系统中通常拥有一个集群leader，比如GFS，HDFS等通常使用一个单独的复制状态机管理leader选举和配置信息以应对leader的崩溃。此外，使用复制状态机的还有Chubby以及ZooKeeper等。</p>
<p>复制状态机通过复制日志实现，如下图所示。每个服务器都会存储一份日志，日志存储的是一系列命令，而服务器的状态机会按顺序执行这些日志中的命令。每份日志中以同样的顺序存储了同样的命令，而状态机以同样的顺序执行这些相同的命令。每台服务器的状态机都是确定的，它们以同样的顺序执行同样的命令，最终的状态和输出也必然是一样的。</p>
<p><img src="/img/共识算法/复制状态机.png" alt="复制状态机" title="复制状态机"></p>
<p>保持复制日志的一致性就是一致性算法的工作了。服务器上的一致性模块接收客户端命令并添加命令到它的日志中。它与其他服务器通信以保证每个日志最终都以相同的顺序包含相同的命令，即便过程中有服务器宕机了。一旦客户端命令正确的复制了，每个服务器的状态机按照日志中顺序处理这些命令，并将输出返回给客户端。最终，这些服务器看起来就像是一台高可用的状态机。</p>
<p>应用到实际系统中的一致性算法通常具备下面几个特性：</p>
<p>（1）保证安全。在所有的非拜占庭将军条件下保证安全，包括网络延迟，分区，丢包，乱序等；</p>
<p>（2）高可用。只要集群中的服务器有大多数(超过一半)可用，系统即是可用的。比如5台服务器的集群可用允许2台服务器宕机而不影响服务；</p>
<p>（3）不依赖时序保证日志的一致性。错误的时钟和极端的消息延迟在最坏情况下才会导致可用性问题；</p>
<p>（4）在通常情况下，只要集群中大部分服务器对过程调用做出响应，命令就可以完成，少数慢服务器不会影响整体系统性能</p>
<h4 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h4><p>这里有关于Raft的<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">动画演示</a>，Raft包括三种角色：leader、candidate 和 follower，其状态变迁如下图：</p>
<p><img src="/img/共识算法/领导选举.png" alt="领导选举" title="领导选举"></p>
<p>（1）Leader 选举。</p>
<p>处于Follower状态的节点在一个随机的超时时间(称之为Election timeout，注意每次都要随机选择一个超时时间，这个超时时间通常为150-300毫秒，我在实验中设置的是300+ms内没有收到投票或者日志复制和心跳包的RPC，则会变成Candidate状态。</p>
<p>处于Candidate状态的节点会马上开始选举投票。它先投自己一票，然后向其他节点发送投票，这个请求称之为Request VoteRPC。如果获得了过半的节点投票，则转成Leader状态。如果投票给了其他节点或者发现了更新任期(Term，解释一下，Term=4，进行过4次选举leader)的指令(如更新任期的选举投票和日志复制指令，则转为Follower状态。如果选举超时没有得到过半投票，则保持Candidate状态开始一个新一轮选举投票。</p>
<p>处于Leader状态的节点会定期发送(这个时间为HeartbeatTimeout，通常要远小于选举超时，实验中我设置的位50ms)AppendEntries RPC请求给其他节点。如果发现了更新任期的指令，则转为Follower状态.</p>
<p>选举投票需要两个条件：</p>
<p>条件一：请求投票的节点的任期必须大于等于本节点且本节点还没有投过票给其他节点(包括投票给自己)。</p>
<p>条件二：请求投票的节点的日志必须是包含了最新提交日志的节点，这是为了保证日志安全增加的限制条件。如何保证请求投票节点包含了最新提交日志呢？可以比较两个节点最后一条日志的任期，如果任期不一样，则任期大的日志更新；如果任期一样，则日志更长的更新。</p>
<p>（2）同步log。</p>
<p>Raft是强Leader机制，日志只能从Leader复制到其他节点。日志项LogEntry包括index，term，command三个元素。其中index为日志索引，term为任期，而command为具体的日志内容，如下图所示：</p>
<p><img src="/img/共识算法/日志格式.png" alt="日志格式" title="日志格式"></p>
<p>通常的日志复制流程是这样的:<br>A. 客户端发送请求给Leader；<br>B. Leader接收客户端请求，先将请求命令作为一个日志项(LogEntry)append到自己的log中；<br>C. Leader然后在最近的一个Heartbeat timeout时发送 Append Entries RPC给Follower节点；<br>D. 一旦日志提交成功，此时日志处于Uncommitted状态，当过半节点添加log成功后，则Leader提交该日志给状态机，返回给客户端写入成功；并在接下来的Append Entries RPC中通知其他节点提交该日志；Follower节点提交日志到自己的状态机中；<br>E. 如果Leader节点挂了，其他Follower节点会在超时后重新选举新的Leader。而如果有宕机或者慢的Follower节点，则Leader会不断重试直到成功。</p>
<p>即便出现网络分割，集群中同时存在多个Leader时，也不会有问题。假定5个节点的集群分割成了3节点和2节点两个大小集群，3节点大集群因为数目3过半，可成功提交日志，而节点数不够的小集群没法成功提交日志。当网络恢复时，因为另外分割的一个大集群已经成功提交了日志，最终新的Leader会在大集群中产生(基于选举投票的条件二保证)并同步到之前分割的小集群节点中。</p>
<p>关于日志复制的几个要点：</p>
<p>-不同的服务器上面的提交的相同的索引和任期的日志项的command一定相同，而且这个日志项之前的所有日志项都相同；<br>-如果一个日志项被提交，则它之前索引的所有日志项也肯定已经提交；<br>-Leader从来都不覆盖自己的日志。其他状态节点如果出现与当前Leader日志不一致，则需要更新日志，包括写入新的日志和删除不一致的日志；<br>-Leader提交过的日志一定会出现将来新的Leader中；<br>-Leader要保证安全的提交日志，必须满足这两个提交规则：日志条目已经复制到大多数Follower节点，Leader当前任期的新日志条目至少有一个复制到了大多数Follower节点。</p>
<h4 id="Raft算法的例子：consul"><a href="#Raft算法的例子：consul" class="headerlink" title="Raft算法的例子：consul"></a>Raft算法的例子：consul</h4><p>Only Consul server nodes participate in Raft and are part of the peer set. All client nodes forward requests to servers. Part of the reason for this design is that, as more members are added to the peer set, the size of the quorum also increases. This introduces performance problems as you may be waiting for hundreds of machines to agree on an entry instead of a handful.</p>
<p>When getting started, a single Consul server is put into “bootstrap” mode. This mode allows it to self-elect as a leader. Once a leader is elected, other servers can be added to the peer set in a way that preserves consistency and safety. Eventually, once the first few servers are added, bootstrap mode can be disabled. </p>
<p>Since all servers participate as part of the peer set, they all know the current leader. When an RPC request arrives at a non-leader server, the request is forwarded to the leader. If the RPC is a query type, meaning it is read-only, the leader generates the result based on the current state of the FSM. If the RPC is a transaction type, meaning it modifies state, the leader generates a new log entry and applies it using Raft. Once the log entry is committed and applied to the FSM, the transaction is complete.</p>
<p>Because of the nature of Raft’s replication, performance is sensitive to network latency. For this reason, each datacenter elects an independent leader and maintains a disjoint peer set. Data is partitioned by datacenter, so each leader is responsible only for data in their datacenter. When a request is received for a remote datacenter, the request is forwarded to the correct leader. This design allows for lower latency transactions and higher availability without sacrificing consistency.</p>
<p><img src="/img/共识算法/consul.png" alt="consul架构图" title="consul架构图"></p>
<h3 id="gossip算法"><a href="#gossip算法" class="headerlink" title="gossip算法"></a>gossip算法</h3><p>Gossip 协议是电脑之间的通信协议，启发来源于现实社会的流言蜚语。现代分布式系统通常用gossip协议来解决一些用其他方法难以解决的问题，可能是因为当前网络有一个不便的问题——过于庞大，或许是因为gossip协议有时候是最为行之有效的方法。Gossip协议又名“传染病协议”(epidemic protocol)，因为gossip协议传播信息的方式有时候类似于生物体内的病毒传播。Gossip协议基于”SWIM: Scalable Weakly-consistent Infection-style Process Group Membership Protocol”加上一点改动，增加了传播速度和收敛率。Gossip是分布式系统中被广泛使用的协议，其主要用于实现分布式节点或者进程之间的信息交换。Gossip协议同时满足应用层多播协议所要求的低负载，高可靠和可扩展性的要求。由于其简单而易于实现，当前很多系统（例如Amazon S3，Usenet NNTP等）选择基于Gossip协议以实现应用层多播的功能。</p>
<p>Gossip Protocol利用一种随机的方式将信息散播到整个网络中。正如Gossip本身的含义一样，Gossip协议的工作流程即类似于绯闻的传播，或者流行病的传播。具体而言Gossip Protocol可以分为Push-based和Pull-based两种。Push-based Gossip Protocol的具体工作流程如下：</p>
<p>（1）网络中的某个节点随机的选择其他b个节点作为传输对象<br>（2）该节点向其选中的b个节点传输相应的信息<br>（3）接收到信息的节点重复完成相同的工作</p>
<p>Pull-based Gossip Protol的协议过程刚好相反：</p>
<p>（1）某个节点v随机的选择b个节点询问有没有最新的信息<br>（2）收到请求的节点回复节点v其最近未收到的信息</p>
<p>理论上，某个节点可以从节点列表随机地选择b个节点，但是实际上这个是不符合实际情况的，因为需要每一个节点都去存储一份完整的节点列表，这个存储和维护起来并不实际。因此，每个节点实际上只维护相对很小的节点列表并使用gossip来周期性地进行更新。</p>
<h4 id="gossip模型"><a href="#gossip模型" class="headerlink" title="gossip模型"></a>gossip模型</h4><p>假设网络中有N个节点，每个节点有相应的地址，并且维护着一份c(c &lt; N)个节点的列表，列表中的每个节点由网络地址address和代表鲜活度的age构成。每个节点会周期性地执行gossip协议来更新节点列表，这个允许网络拓扑信息在节点之间进行传播。基本的思想是每个节点随机地选择列表中的自己进行传播，这个会避免包含太多的多余的信息导致网络的过载。例如peer的选择，可以随机地选择或者选择哪个age最大的节点；传播的策略，比如push或者pushpull分别对应着单向和双向的交换信息。假设某个节点A push所有的信息给节点B，节点B需要策略来选择信息。每个节点的age是通过hop-counts来更新的。</p>
<p>We assume that the sending node pushes the whole of its view to the receiving node. Finally, the receiving node requires a strategy for view selection, which combines the incoming and the existing view information. In our model, we in fact use hop-counts as a coarse (bounded) measure of the age of each node descriptor. A receiving node increments the the hop-count of all the incoming descriptors, merges these with the descriptors in its own view (keeping the entry with the youngest count in cases of duplication) and then keeps the c newest entries from the combined set.</p>
<p>With regards to the timing of the protocol, we assume that the exchange of data between nodes occurs periodically (with some fixed period) and that each node sends its data exactly once in each round of execution. Such a scheme can be achieved in practice through synchronisation of local clocks. Due to the distributed nature of the system, however, the order in which the nodes participate in each round is unknown (and may be different each time).</p>
<p>The gossip protocol therefore exhibits both probabilistic behaviour (random peer selection) and nondeterministic behaviour (scheduling of nodes within a round) and is naturally modelled as a Markov decision process (MDP). </p>
<h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.jianshu.com/p/1f5cb602dc71" target="_blank" rel="noopener">分布式系统学习2-Raft算法分析与实现</a></li>
<li><a href="https://www.jianshu.com/p/99562bfec5c2" target="_blank" rel="noopener">深入浅出 Raft - Membership Change</a></li>
<li><a href="https://en.wikipedia.org/wiki/Gossip_protocol" target="_blank" rel="noopener">Gossip protocol-Wikipedia</a></li>
<li><a href="http://kaiyuan.me/2015/07/08/Gossip/" target="_blank" rel="noopener">Gossip 协议简介</a></li>
<li><a href="http://www.prismmodelchecker.org/casestudies/gossip.php" target="_blank" rel="noopener">Gossip Protocol</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="小黄驴" />
            
              <p class="site-author-name" itemprop="name">小黄驴</p>
              <p class="site-description motion-element" itemprop="description">信息安全的小搬运工</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/laolv421" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:laolv421@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小黄驴</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
